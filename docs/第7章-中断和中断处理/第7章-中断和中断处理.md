<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [第7章-中断和中断处理](#第7章-中断和中断处理)
	- [中断引入](#中断引入)
	- [中断的基本处理过程](#中断的基本处理过程)
	- [中断常识](#中断常识)
	- [中断源类型](#中断源类型)
	- [外设可屏蔽中断](#外设可屏蔽中断)
	- [中断相关汇编指令](#中断相关汇编指令)
	- [中断描述符表IDT表](#中断描述符表idt表)
	- [中断处理过程](#中断处理过程)
	- [中断服务例程+中断处理程序](#中断服务例程中断处理程序)
	- [中断线共享的数据结构](#中断线共享的数据结构)
	- [END](#end)

<!-- /TOC -->
# 第7章-中断和中断处理

## 中断引入

![1530522238483.png](image/1530522238483.png)

![1530522260669.png](image/1530522260669.png)

![1530522926002.png](image/1530522926002.png)

![1530522987842.png](image/1530522987842.png)


* 程序轮询方式检测

![1530522998506.png](image/1530522998506.png)

* 中断 - 设定中断之后处理别的事情。

![1530523058253.png](image/1530523058253.png)

![1530523137220.png](image/1530523137220.png)

![1530523147193.png](image/1530523147193.png)

![1530523179729.png](image/1530523179729.png)

## 中断的基本处理过程

![1530523233920.png](image/1530523233920.png)

* 中断CPU执行中断处理程序，其实CPU正在执行或者执行不可中断的状态时候是不回去检测中断，凡事可以检测中断就说明可以被打断。

* 信号处理机制

## 中断常识

![1530523606509.png](image/1530523606509.png)

* 中断跟体系结构相关度很高，不同体系结构中断系统不同，指令不同。一般得根据芯片厂家手册得出原理。

## 中断源类型

![1530524123715.png](image/1530524123715.png)

## 外设可屏蔽中断

![1530524174565.png](image/1530524174565.png)

* 古董级，用两个中断控制器拼接形成能够响应15个中断的控制器

![1530524229504.png](image/1530524229504.png)

* 有了中断控制器，把CPU从轮询中解放出来
* 提供机制而不是策略，在这套机制下扩展，不变应万变
* **中断的本质就是信号传递**
* 如何关闭中断？清楚eflag标志，或者修改中断控制器响应寄存器

![1530524753765.png](image/1530524753765.png)

* 异常就是CPU内部问题，不可屏蔽，同步。
* intel把不可屏蔽中断当做异常来处理
* 芯片手册是最权威的老师
* 处理异常的时候，必须原子操作，屏蔽中断和其他异常

## 中断相关汇编指令

![1530524868523.png](image/1530524868523.png)

## 中断描述符表IDT表

![1530524972821.png](image/1530524972821.png)

* 中断向量表 ~ 中断描述符表 = 段表 8B每项


![1530525151217.png](image/1530525151217.png)

* 中断描述符比表在内核定义，固定不变。高度相关体系结构

![1530525256943.png](image/1530525256943.png)


![1530525290730.png](image/1530525290730.png)

* 初始化阶段基本都是汇编代码，然后默认设定为空值，之后逐渐赋值
* 系统调用 = 系统门？
* 用户程序不能直接访问系统资源，只能间接访问系统资源

![1530532481076.png](image/1530532481076.png)

* gcc、C语言、intel体系结构、汇编

![1530532603537.png](image/1530532603537.png)

* 按照intel体系结构定义一些数据结构，遵循规则
* 这几种们最终都是调用_set_gate

![1530532664114.png](image/1530532664114.png)

* 引入场景更方便语言的学习

![1530532765052.png](image/1530532765052.png)

* 256个中断向量（0~255），固定分配一波给啥啥啥。
* 一个中断向量对应一个中断处理程序

![1530532893039.png](image/1530532893039.png)

![1530533001106.png](image/1530533001106.png)

* 跳过系统调用0x80中断向量

![1530533032528.png](image/1530533032528.png)

* 统一方式形成函数名和函数体 = 宏实现

## 中断处理过程

![1530533117097.png](image/1530533117097.png)

![1530533331721.png](image/1530533331721.png)

* 当前指令执行完成之后判断中断是否有信号，这是硬件的工作。

![1530533373993.png](image/1530533373993.png)

![1530533628663.png](image/1530533628663.png)

* 不管中断还是异常，反正都是跑到IDT表中寻找

![1530533659046.png](image/1530533659046.png)


## 中断服务例程+中断处理程序

![1530533766596.png](image/1530533766596.png)

* 每个中断请求都有自己独立的中断服务例程
* 不加区别？
* 中断线对应中断处理程序
* 中断请求对应中断服务例程

## 中断线共享的数据结构

![1530533908655.png](image/1530533908655.png)

![1530534058391.png](image/1530534058391.png)


![1530534114580.png](image/1530534114580.png)

* 主设备号，次设备号

![1530534159848.png](image/1530534159848.png)

* request_irq、free_irq

![1530534217837.png](image/1530534217837.png)

* 共享中断线的处理程序叫中断服务例程
* 15条中断线对应15个中断处理程序。有些中断线可共享，有些不可以
* 原来对于计算机设备比较少的时候，可能一个中断线好可以对应一个中断处理程序(非共享中断线)，这时候参数4为NULL，没有任何用，但随着计算机设备的增加，一个中断线号对应一个中断处理程序已经不太现实，这个时候就使用了共享的中断线号，多个设备使用同一个中断线号，同一个中断设备线号的所有处理程序链接成一个链表，这样当在共享中断线号的方式下一个中断产生的时候，就要遍历其对应的处理程序链表，但这个中断是由使用同一个中断线号的多个设备中间的一个产生的，不可能链表里面的所有处理程序都调用一遍吧，呵呵，这个时候就该第四个参数派上用场了。
* 因为多个设备共享同一个中断线号，当中断产生的时候到底是那一个设备产生的中断呢，这个就取决于第四个参数dev_id，这个参数必须是唯一的，也就是能区分到底是那个设备产生的中断，而且从第二个参数可以看出来，这个参数被传入中断处理程序(第二个参数)，可以这么理解，当中断产生的时候，如果是共享的中断线号，则对应链表的所有中断处理程序都被调用，不过在每个中断处理程序的内部首先检查(参数信息以及设备硬件的支持)是不是这个中断处理程序对应的设备产生的中断，如果不是，立即返回，如果是，则处理完成，如果链表中没有一个是，则说明出现错误。

![1530534481555.png](image/1530534481555.png)

![1530534915099.png](image/1530534915099.png)

![1530535218220.png](image/1530535218220.png)

* 0~31给异常，32开始外设。** irq n = 32+n **

![1530535858626.png](image/1530535858626.png)

![1530535901621.png](image/1530535901621.png)

![1530536077030.png](image/1530536077030.png)



## END
